5 Mistakes C/C++ Devs make writing Go
A newbie's journey into Go

Aug 29 2018

Nyah Check
Software Engineer, Altitude Networks
nyah@altitudenetworks.com
https://github.com/Ch3ck
@nyah_check


* Why am I here?

- Wrote C/C++ for close to 5 years before Go.

- Brought bad C style code in Go and had a lot of issues


* What you'll learn...

- Learn from my mistakes

- Avoid some common pitfalls newbies face writing Go


* Agenda

I classified the 5 mistakes under 4 topics:

- Escape Analysis
- Memory leaks
- Goroutine leaks
- Error handling

I'll be open to questions at the end of the presention


* One more thing ...

This is a discussion

If you don't understand something, or think what I'm saying is incorrect, please ask.

* Escape Analysis

* Mistake 1: New doesn't mean heap && var doesn't mean stack

An early mistake was to minimize _escape_analysis_ and it's possible implications my program's performances


Consider the following _C++_ code
.code 01-new-doesnt-mean-heap/examples/heap.cpp /START OMIT/,/END OMIT/

* Wrong assumptions..

- In C++, we know *new* allocates to the value stored at *a* on the heap.

- In Go, we don't really know for sure. 
- May be the *new* keyword was stolen from C++ as a result might likely be allocated on the heap?

- Given my C++ bias, I thought minimizing it's use will reduce _heap_ allocation.


* Let's look at some code...

.code 01-new-doesnt-mean-heap/examples/heap.go /START OMIT/,/END OMIT/

* Question

Where do we think the *vv* variable will be allocated? *stack* or *heap*?

* Let's look at the compiler escape decisions output

    $ go run -gcflags -m main.go
    # command-line-arguments
    ./main.go:6:6: can inline newIntStack
    ./main.go:12:39: inlining call to newIntStack
    ./main.go:7:11: new(int) escapes to heap
    ./main.go:12:27: *(*int)(~r0) escapes to heap
    ./main.go:12:39: main new(int) does not escape         <--- Surprise!!!
    ./main.go:12:26: main ... argument does not escape
    0

* Let's take a look at another example

    package main

    import "fmt"

    func main() {
        x := "GOPHERCON-2018"
        fmt.Println(x)
    }

* Where will x be allocated?

Stack or Heap?

* Let's find out...

    ➜  examples git:(master) ✗ go run -gcflags -m main.go
    # command-line-arguments
    ./main.go:15:13: x escapes to heap        <---- STRANGE THINGS!
    ./main.go:15:13: main ... argument does not escape
    GOPHERCON-2018
    ➜  examples git:(master) ✗


It's surprising to see *x* which not called outside may is allocated on the heap instead.

* Why?

I’ll pass the -m option multiple times to make the output more verbose:

    ➜  examples git:(master) ✗ go run -gcflags '-m -m'  main.go
    # command-line-arguments
    ./main.go:13:6: cannot inline main: non-leaf function
    ./main.go:15:13: x escapes to heap
    ./main.go:15:13:        from ... argument (arg to ...) at ./main.go:15:13
    ./main.go:15:13:        from *(... argument) (indirection) at ./main.go:15:13
    ./main.go:15:13:        from ... argument (passed to call[argument content escapes]) at ./main.go:15:13
    ...                                          // <-- X is called by a funtion above which escapes! -->
    ./main.go:15:13: main ... argument does not escape
    GOPHERCON-2018
    ➜  examples git:(master) ✗

* What happened?

So looking at L15:13

- x is passed to a function argument which `escapes`
- So x is heap allocated instead.

This is very confusing/counterintuitive to a C/C++ developer, yet this is how Go works.


* Lessons

- Escape analysis is very important in writing more performant Go programs, yet there's no language specification on this.
- Some of the compiler's escape analysis decisions are counterintuitive, yet trial and error is the only way to know
- Do not make assumptions, rather do static analysis on the code and make informed decisions.


* Escape Analysis guidelines

- Functions calling other functions
- references assigned to struct members
- slices and maps
- pointers to variables

* Conclusion
"If a reference to a variable is returned from a function where it’s declared, it ‘escapes’ and is heap allocated instead"
.caption

* Memory Leaks

* Mistake 2: Do not defer in an infinite Loop

The *defer* statement is used to clean up resources after you open up a resource(e.g. file, connection etc)

So an idiomatic way will be:

    fp, err := os.Open("path/to/file.text")
    if err != nil {
        //handle error gracefully
    }
    defer fp.Close()

This snippet is guaranteed to work even if cases where there’s a panic and it’s *standard* Go practice. 

* So what's the problem?

In very large files where resources cannot be tracked and freed properly, this becomes a problem.

Consider a file monitoring program in *C* where:
- check a database for changes to files
- perform some operation(logging, send requests etc)

* Something like this might work
.code 02-do-not-defer-in-infinite-loop/examples/file.c /START OMIT/,/END OMIT/
This will be sure to open and close up the files once the operations are done.

* However in Go
.code 02-do-not-defer-in-infinite-loop/examples/main.go /START OMIT/,/END OMIT/

*Problems:*
- Deferred code never executes since the function has not returned
- So memory clean up never happens and it’s use keeps piling up
- Files will never be closed, therefore causing loss of data due to lack of flush.


* How do I fix this?

- Spin up a goroutine for each file monitoring
- This ensures everything is bound to the context
- Hence files are opened and closed

* Solution

.code examples/main.go /START FIX/,/END FIX/

* Lessons learned

- Since defer is tied to the new function context, we are sure it's executed and memory is flushed when files close
- When defer executes we are certain our goroutine finished execution
- Defer doesn not execute until the function returns, so no memory leaks result

* Conclusion

"A *defer* statement invokes a function whose execution is deferred to the moment the surrounding function returns"
.caption

* Mistake 3: Keeping pointers in an accessible(although not visible) part of a slice

[[02-do-not-defer-in-infinite-loop/do-not-defer-in-infinite-loop.slide][Do not defer in an infinite loop]]