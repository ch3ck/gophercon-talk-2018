5 Mistakes C/C++ Devs make writing Go
A newbie's journey into Go

Aug 29 2018

Nyah Check
Software Engineer, Altitude Networks
nyah@altitudenetworks.com
https://github.com/Ch3ck
@nyah_check


* Why am I here?

- Wrote C/C++ for close to 5 years before Go.

- Brought bad C style code in Go and had a lot of issues


* What you'll learn...

- Learn from my mistakes

- Avoid some common pitfalls newbies face writing Go


* Agenda

I classified the 5 mistakes under 4 topics:

- Escape Analysis
- Memory leaks
- Goroutine leaks
- Error handling

I'll be open to questions at the end of the presention


* One more thing ...

This is a discussion

If you don't understand something, or think what I'm saying is incorrect, please ask.

* Escape Analysis

* Mistake 1: New doesn't mean heap && var doesn't mean stack

An early mistake was to minimize _escape_analysis_ and it's possible implications my program's performances


Consider the following _C++_ code
.code 01-new-doesnt-mean-heap/examples/heap.cpp /START OMIT/,/END OMIT/

* Wrong assumptions..

- In C++, we know *new* allocates to the value stored at *a* on the heap.

- In Go, we don't really know for sure. 
- May be the *new* keyword was stolen from C++ as a result might likely be allocated on the heap?

- Given my C++ bias, I thought minimizing it's use will reduce _heap_ allocation.


* Let's look at some code...

.code 01-new-doesnt-mean-heap/examples/heap.go /START OMIT/,/END OMIT/

* Question

Where do we think the *vv* variable will be allocated? *stack* or *heap*?

* Let's look at the compiler escape decisions output

    $ go run -gcflags -m main.go
    # command-line-arguments
    ./main.go:6:6: can inline newIntStack
    ./main.go:12:39: inlining call to newIntStack
    ./main.go:7:11: new(int) escapes to heap
    ./main.go:12:27: *(*int)(~r0) escapes to heap
    ./main.go:12:39: main new(int) does not escape         <--- Surprise!!!
    ./main.go:12:26: main ... argument does not escape
    0

* Let's take a look at another example

    package main

    import "fmt"

    func main() {
        x := "GOPHERCON-2018"
        fmt.Println(x)
    }

* Where will x be allocated?

Stack or Heap?

* Let's find out...

    ➜  examples git:(master) ✗ go run -gcflags -m main.go
    # command-line-arguments
    ./main.go:15:13: x escapes to heap        <---- STRANGE THINGS!
    ./main.go:15:13: main ... argument does not escape
    GOPHERCON-2018
    ➜  examples git:(master) ✗


It's surprising to see *x* which not called outside may is allocated on the heap instead.

* Why?

I’ll pass the -m option multiple times to make the output more verbose:

    ➜  examples git:(master) ✗ go run -gcflags '-m -m'  main.go
    # command-line-arguments
    ./main.go:13:6: cannot inline main: non-leaf function
    ./main.go:15:13: x escapes to heap
    ./main.go:15:13:        from ... argument (arg to ...) at ./main.go:15:13
    ./main.go:15:13:        from *(... argument) (indirection) at ./main.go:15:13
    ./main.go:15:13:        from ... argument (passed to call[argument content escapes]) at ./main.go:15:13
    ...                                          // <-- X is called by a funtion above which escapes! -->
    ./main.go:15:13: main ... argument does not escape
    GOPHERCON-2018
    ➜  examples git:(master) ✗

* What happened?

So looking at L15:13

- x is passed to a function argument which `escapes`
- So x is heap allocated instead.

This is very confusing/counterintuitive to a C/C++ developer, yet this is how Go works.


* Lessons

- Escape analysis is very important in writing more performant Go programs, yet there's no language specification on this.
- Some of the compiler's escape analysis decisions are counterintuitive, yet trial and error is the only way to know
- Do not make assumptions, rather do static analysis on the code and make informed decisions.


* Escape Analysis guidelines

- Functions calling other functions
- references assigned to struct members
- slices and maps
- pointers to variables

* Conclusion
"If a reference to a variable is returned from a function where it’s declared, it ‘escapes’ and is heap allocated instead"
.caption

* Memory Leaks

* Mistake 2: Do not defer in an infinite Loop

The *defer* statement is used to clean up resources after you open up a resource(e.g. file, connection etc)

So an idiomatic way will be:

    fp, err := os.Open("path/to/file.text")
    if err != nil {
        //handle error gracefully
    }
    defer fp.Close()

This snippet is guaranteed to work even if cases where there’s a panic and it’s *standard* Go practice. 

* So what's the problem?

In very large files where resources cannot be tracked and freed properly, this becomes a problem.

Consider a file monitoring program in *C* where:
- check a database for changes to files
- perform some operation(logging, send requests etc)

* Something like this might work
.code 02-do-not-defer-in-infinite-loop/examples/file.c /START OMIT/,/END OMIT/
This will be sure to open and close up the files once the operations are done.

* However in Go
.code 02-do-not-defer-in-infinite-loop/examples/main.go /START OMIT/,/END OMIT/

*Problems:*
- Deferred code never executes since the function has not returned
- So memory clean up never happens and it’s use keeps piling up
- Files will never be closed, therefore causing loss of data due to lack of flush.


* How do I fix this?

- Spin up a goroutine for each file monitoring
- This ensures everything is bound to the context
- Hence files are opened and closed

* Solution

.code 02-do-not-defer-in-infinite-loop/examples/main.go /START FIX/,/END FIX/

* Lessons learned

- Since defer is tied to the new function context, we are sure it's executed and memory is flushed when files close
- When defer executes we are certain our goroutine finished execution
- Defer doesn not execute until the function returns, so no memory leaks result

* Conclusion

"A *defer* statement invokes a function whose execution is deferred to the moment the surrounding function returns"
.caption


* Mistake 3: Keeping pointers in an accessible(although not visible) part of a slice

- Prior to Go 1.2 there was a memory safety issue with slices, where you could literally access regions in memory you're not legally permitted to:
- This would create problems where you'll unitentionally rewrite regions of memory and will increase your pain.

* Let's use an example.
Consider the slice:

	a := []*int{new(int), new(int)}
	a = a[:1]
	fmt.Println(a) // [&0]

	// second element is not garbage collected, because it's *still* accessible
	a = a[:2] //[&0] // <-- Illegal memory access
	fmt.Println(a)


Our output will be:

    ➜  examples git:(master) ✗ go run main.go
    [0xc420016090 0xc420016098]
    [0xc420016090]
    [0xc420016090 0xc420016098]


* What are some of the problems?

- This can cause problems later on where you can write data to parts of the slice you shouldn’t have access to
- Memory will be garbage collected as wrongly assumed.
- If you can access certain parts of memory you don’t legally have access to, it may be a source for exploits

* How do you solve this then?

Go 1.2++ added 3-Index-Slice  operation

- This enables you to specify the cap during slicing.

- The restricted slice capacity provides a level of protection to the underlying array and gives us more control over append operations


* How do we use it then

Rewriting our code gives

    a := []*int{new(int), new(int)}
    a = a[:1:1] // THREE INDEX SLICE OPERATION
    fmt.Println(a) // [&0]

    // second element is garbage collected, and can no longer be accessible
    a = a[:2]
    fmt.Println(a)

* Our output becomes ...

    ➜  examples git:(master) ✗ go run main.go
    [0xc420016090 0xc420016098]
    [0xc420016090]
    panic: runtime error: slice bounds out of range

    goroutine 1 [running]:
    main.main()
        /Users/nyahcheck/go/src/github.com/Ch3ck/5-mistakes-c-cpp-devs-make-writing-go/03-pointer-in-non-visible-slice-portion/examples/main.go:27 +0x1ae
    exit status 2

Our slice cap was set to 1, we can't access regions of memoery we don't have permissions to, rightly creating a panic.

* Lesson

Three index slicing creates a memory safety feature for your Go programs which pervents certain parts of memory to accesses/modified intentionally or otherwise.



* Goroutine leaks

* Mistake 4
[[../04-error-handling-with-channels/error-handling-with-channels.slide][Avoiding  goroutine leaks]]

* Error handling
* Mistake 5: Errors are not just strings, but much more




* Discussion



Any questions?


* Conclusion


- *Understand* Escape analysis by looking at the compiler decisions, do not make *reasonable guesses*.


- *Defer* executes only when the function returns. Using it in a infinite loop is a *code smell*.


- Three Index_slices adds a memory *safety* utility in Go, use it.

* Conclusion (cont.)

- *Profile* your Go code to identify bottlenecks early on, it's a good practice.

- Errors in Go are not just strings, but much more.

- Wrap errors to preserve context and handle them gracefully.


* There are many more errors C/C++ devs make

Just remember ...

- Go is not C/C++

- "Programming in Go is like being young again (but more productive!)."
.caption